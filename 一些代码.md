/*
*题目：一只青蛙一次可以跳上1级台阶，也可以跳*上2级。求该青蛙跳上一个n级的台阶总共有多少&*种跳法（先后次序不同算不同的结果）。
*思路：典型的斐波拉契问题
*/

```
public int JumpFloor(int target) {
        if(target==0)
            return 0;
            else if(target==1||target==2)
                return target;
        else return JumpFloor(target-1)+JumpFloor(target-2);

    }
```
/*
*题目：一只青蛙一次可以跳上1级台阶，也可以**跳上2级……它也可以跳上n级。求该青蛙跳上一个*n级的台阶总共有多少种跳法。
*/
    直接上代码：
    
```
 public int JumpFloorII(int target) {
        if(target==0){
            return 0;
        }
        if(target==1){
            return 1;
        }
        return 2*JumpFloorII(target-1);
    }
```
题目：
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
思路：也是一个典型的斐波拉契问题


```
public int RectCover(int target) {
        if(target<=0){
            return 0;
        }else if(target==1||target==2){
            return target;
        }else{
            return RectCover(target-1)+RectCover(target-2);
        }
    }
```
题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示


```
  public int NumberOf1(int n) {
        int count=0;
        if(n<0){
            n=n&0x7FFFFFFF;
            count++;
        }
        while(n!=0){
            if(n%2!=0)
                count++;
            n=n/2;
        }
        return count;
    }
```
题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方


```
   public double Power(double base, int exponent) {
        double result=base;
        if(exponent==0)
            return 1;
        else if (exponent>0){
            for(int i=1;i<exponent;i++){
                result*=base;
            }
            return result;
        }else{
            if(base==0)
                return 0;
            for(int j=1;j<-exponent;j++){
                result*=base;
            }
            return 1/result;
        }
  }
```
 
 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
 
 
```
 public void reOrderArray(int [] array) {
       int j=0;
       int m=0;
        for(int i=0;i<array.length;i++){
            if(array[i]%2==1){
                int temp=array[i];
                int ti=i;
                for(;ti>0;ti--){
                    array[ti]=array[ti-1];
                }
                array[0]=temp;
                j=i;
                break;
            }
        }
        for(++j;j<array.length;j++){
            if(array[j]%2==1){
                int temp=array[j];
                int tj=j;
                for(;tj>m;tj--){
                    array[tj]=array[tj-1];
                }
                array[++m]=temp;
            }
        }
    }
```

题目：输入一个链表，输出该链表中倒数第k个结点。
思路：定义两个指针，倒数第k个，就是正数第n-k个


```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(null==head)
            return null;
        ListNode p1=head,p2=head;
        while(k>0&&p2!=null){
            p2=p2.next;
            k--;
        }
        if(p2==head||(p2==null&&k>0))
            return null;
        while(p2!=null){
            p1=p1.next;
            p2=p2.next;
        }
   return p1;
    }
}
```
题目：输入一个链表，反转链表后，输出新链表的表头。


```
public ListNode ReverseList(ListNode head) {
        if(null==head)
            return null;
        ListNode pre=null;
        ListNode next=null;
        while(null!=head){
            next=head.next;
            head.next=pre;
            pre=head;
            head=next;
        }
   return pre;
    }
```
题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。


```
 public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode list=null;
        if(null==list1&&null==list2)
            return null;
        if(null==list1)
            return list2;
        if(null==list2)
            return list1;
        if(list1.val<list2.val){
            list=list1;
           list.next= Merge(list1.next,list2);
        }else{
            list=list2;
            list.next=Merge(list1,list2.next);
        }
        return list;     
    }
```
题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(null==root2||null==root1)
            return false;
        return isSubtree(root1,root2)||HasSubtree(root1.left,root2)
            ||HasSubtree(root1.right,root2);
     
    }
    public boolean isSubtree(TreeNode root1,TreeNode root2){
        if(null==root2){
            return true;
        }
        if(null==root1){
            return false;
        }
        if(root1.val==root2.val){
            return isSubtree(root1.left,root2.left)&&isSubtree(root1.right,root2.right);
        }else{
            return false;
        }
    }
```
题目：操作给定的二叉树，将其变换为源二叉树的镜像。


```
   public void Mirror(TreeNode root) {
        if(null==root)
            return;
        if(null==root.left&&null==root.right)
            return;
        TreeNode temp=root.right;
        root.right=root.left;
        root.left=temp;
        if(root.right!=null)
           Mirror(root.right);
         if(root.left!=null)
           Mirror(root.left);
    }
```
题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.


```
   public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> list=new ArrayList<Integer>();
	 if(null==matrix)
		 return null;
	 int row=matrix.length;//宽
	 int col=matrix[0].length;//长
	 if(row==0||col==0)
		 return null;
	 if(row==1) {
		 for(int i=0;i<col;i++) {
			 list.add(matrix[0][i]);
			 
		 }
		 return list;			
	 }
		 if(col==1) {
			 for(int i=0;i<row;i++) {
				 list.add(matrix[i][0]);
			 }
			 return list;
		 }
		 
		 for(int i=0;i<row-i;i++) {
			 int j=i;
			 if(j<col-i) {
				 //一圈的上边
				 for(;j<col-i;j++) 
					list.add(matrix[i][j]); 
				 //一圈的右边
				  //一圈的右边
	                for (int k = i + 1; k < row - i; k++) {
	                    list.add(matrix[k][col - 1 - i]);
	                }
	                int f=row-1-i;//下边的行数
	                if(f!=i) {
	                	for(int m=col-i-2;m>=i;m--) {
	                		list.add(matrix[f][m]);
	                	}
	                	
	                	//一圈的左边
	                	for(int n=f-1;n>i;n--) {
	                		list.add(matrix[n][i]);
	                	}
	                }
				 
			 }
		 }
		 return list;       
    }
```
题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））


```
Stack<Integer> tempStack = new Stack<Integer>();
    Stack<Integer> minStack = new Stack<Integer>();
    public void push(int node) {
        tempStack.push(node);
        if(minStack.size()==0)
            minStack.push(node);
        if(node<minStack.peek())
            minStack.push(node);
    }
    
    public void pop() {
        if(tempStack.peek()==minStack.peek()){
             tempStack.pop();
             minStack.pop(); 
        }else
            tempStack.pop();
    }
    
    public int top() {
        return tempStack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
```

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等


```
 public boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack<Integer> stack=new Stack<Integer>();
      if(pushA.length<=0||popA.length<=0)
          return false;
          int j=0;
          for(int i=0;i<pushA.length;i++){
          stack.push(pushA[i]);
          if(stack.peek()==popA[j]){
              stack.pop();
              j++;
              if(j==popA.length-1){
              return true;
              }
          }
          }
        while(!stack.empty()){
            if(stack.pop()!=popA[j++]){
                     return false;
            }
        }
        return true;
    }
```
题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：借助队列实现


```
 public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        Queue<TreeNode> queue=new LinkedList<TreeNode>();
        ArrayList<Integer> list=new ArrayList<Integer>();
        if(null==root)
            return list;
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode temp=queue.poll();
            list.add(temp.val);
            if(null!=temp.left){
                queue.offer(temp.left);
            }
            if(null!=temp.right){
                queue.offer(temp.right);
            }
        }
        return list;
        
    }
```

题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。


```
   public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0){
            return false;
        }
      return  judge(sequence,0,sequence.length-1);
    }
    public boolean judge(int [] sequence,int start,int last){
        if(start>=last){
	            return true;
	        }
	        int i = last;
	        while(i>start && sequence[i-1]>sequence[last]){
	            --i;
	        }
	        for(int j=i-1;j>=start;--j){
	            if(sequence[j]>sequence[last]){
	                return false;
	            }
	        }
	        return (judge(sequence,start,i-1)) && (judge(sequence,i,last-1));
        
    }
```