/*
*题目：一只青蛙一次可以跳上1级台阶，也可以跳*上2级。求该青蛙跳上一个n级的台阶总共有多少&*种跳法（先后次序不同算不同的结果）。
*思路：典型的斐波拉契问题
*/

```
public int JumpFloor(int target) {
        if(target==0)
            return 0;
            else if(target==1||target==2)
                return target;
        else return JumpFloor(target-1)+JumpFloor(target-2);

    }
```
/*
*题目：一只青蛙一次可以跳上1级台阶，也可以**跳上2级……它也可以跳上n级。求该青蛙跳上一个*n级的台阶总共有多少种跳法。
*/
    直接上代码：
    
```
 public int JumpFloorII(int target) {
        if(target==0){
            return 0;
        }
        if(target==1){
            return 1;
        }
        return 2*JumpFloorII(target-1);
    }
```
题目：
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？
思路：也是一个典型的斐波拉契问题


```
public int RectCover(int target) {
        if(target<=0){
            return 0;
        }else if(target==1||target==2){
            return target;
        }else{
            return RectCover(target-1)+RectCover(target-2);
        }
    }
```
题目：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示


```
  public int NumberOf1(int n) {
        int count=0;
        if(n<0){
            n=n&0x7FFFFFFF;
            count++;
        }
        while(n!=0){
            if(n%2!=0)
                count++;
            n=n/2;
        }
        return count;
    }
```
题目：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方


```
   public double Power(double base, int exponent) {
        double result=base;
        if(exponent==0)
            return 1;
        else if (exponent>0){
            for(int i=1;i<exponent;i++){
                result*=base;
            }
            return result;
        }else{
            if(base==0)
                return 0;
            for(int j=1;j<-exponent;j++){
                result*=base;
            }
            return 1/result;
        }
  }
```
 
 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。
 
 
```
 public void reOrderArray(int [] array) {
       int j=0;
       int m=0;
        for(int i=0;i<array.length;i++){
            if(array[i]%2==1){
                int temp=array[i];
                int ti=i;
                for(;ti>0;ti--){
                    array[ti]=array[ti-1];
                }
                array[0]=temp;
                j=i;
                break;
            }
        }
        for(++j;j<array.length;j++){
            if(array[j]%2==1){
                int temp=array[j];
                int tj=j;
                for(;tj>m;tj--){
                    array[tj]=array[tj-1];
                }
                array[++m]=temp;
            }
        }
    }
```

题目：输入一个链表，输出该链表中倒数第k个结点。
思路：定义两个指针，倒数第k个，就是正数第n-k个


```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(null==head)
            return null;
        ListNode p1=head,p2=head;
        while(k>0&&p2!=null){
            p2=p2.next;
            k--;
        }
        if(p2==head||(p2==null&&k>0))
            return null;
        while(p2!=null){
            p1=p1.next;
            p2=p2.next;
        }
   return p1;
    }
}
```
题目：输入一个链表，反转链表后，输出新链表的表头。


```
public ListNode ReverseList(ListNode head) {
        if(null==head)
            return null;
        ListNode pre=null;
        ListNode next=null;
        while(null!=head){
            next=head.next;
            head.next=pre;
            pre=head;
            head=next;
        }
   return pre;
    }
```
题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。


```
 public ListNode Merge(ListNode list1,ListNode list2) {
        ListNode list=null;
        if(null==list1&&null==list2)
            return null;
        if(null==list1)
            return list2;
        if(null==list2)
            return list1;
        if(list1.val<list2.val){
            list=list1;
           list.next= Merge(list1.next,list2);
        }else{
            list=list2;
            list.next=Merge(list1,list2.next);
        }
        return list;     
    }
```
题目：输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```
public boolean HasSubtree(TreeNode root1,TreeNode root2) {
        if(null==root2||null==root1)
            return false;
        return isSubtree(root1,root2)||HasSubtree(root1.left,root2)
            ||HasSubtree(root1.right,root2);
     
    }
    public boolean isSubtree(TreeNode root1,TreeNode root2){
        if(null==root2){
            return true;
        }
        if(null==root1){
            return false;
        }
        if(root1.val==root2.val){
            return isSubtree(root1.left,root2.left)&&isSubtree(root1.right,root2.right);
        }else{
            return false;
        }
    }
```
题目：操作给定的二叉树，将其变换为源二叉树的镜像。


```
   public void Mirror(TreeNode root) {
        if(null==root)
            return;
        if(null==root.left&&null==root.right)
            return;
        TreeNode temp=root.right;
        root.right=root.left;
        root.left=temp;
        if(root.right!=null)
           Mirror(root.right);
         if(root.left!=null)
           Mirror(root.left);
    }
```
题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.


```
   public ArrayList<Integer> printMatrix(int [][] matrix) {
        ArrayList<Integer> list=new ArrayList<Integer>();
	 if(null==matrix)
		 return null;
	 int row=matrix.length;//宽
	 int col=matrix[0].length;//长
	 if(row==0||col==0)
		 return null;
	 if(row==1) {
		 for(int i=0;i<col;i++) {
			 list.add(matrix[0][i]);
			 
		 }
		 return list;			
	 }
		 if(col==1) {
			 for(int i=0;i<row;i++) {
				 list.add(matrix[i][0]);
			 }
			 return list;
		 }
		 
		 for(int i=0;i<row-i;i++) {
			 int j=i;
			 if(j<col-i) {
				 //一圈的上边
				 for(;j<col-i;j++) 
					list.add(matrix[i][j]); 
				 //一圈的右边
				  //一圈的右边
	                for (int k = i + 1; k < row - i; k++) {
	                    list.add(matrix[k][col - 1 - i]);
	                }
	                int f=row-1-i;//下边的行数
	                if(f!=i) {
	                	for(int m=col-i-2;m>=i;m--) {
	                		list.add(matrix[f][m]);
	                	}
	                	
	                	//一圈的左边
	                	for(int n=f-1;n>i;n--) {
	                		list.add(matrix[n][i]);
	                	}
	                }
				 
			 }
		 }
		 return list;       
    }
```
题目：定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））


```
Stack<Integer> tempStack = new Stack<Integer>();
    Stack<Integer> minStack = new Stack<Integer>();
    public void push(int node) {
        tempStack.push(node);
        if(minStack.size()==0)
            minStack.push(node);
        if(node<minStack.peek())
            minStack.push(node);
    }
    
    public void pop() {
        if(tempStack.peek()==minStack.peek()){
             tempStack.pop();
             minStack.pop(); 
        }else
            tempStack.pop();
    }
    
    public int top() {
        return tempStack.peek();
    }
    
    public int min() {
        return minStack.peek();
    }
```

题目：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等


```
 public boolean IsPopOrder(int [] pushA,int [] popA) {
        Stack<Integer> stack=new Stack<Integer>();
      if(pushA.length<=0||popA.length<=0)
          return false;
          int j=0;
          for(int i=0;i<pushA.length;i++){
          stack.push(pushA[i]);
          if(stack.peek()==popA[j]){
              stack.pop();
              j++;
              if(j==popA.length-1){
              return true;
              }
          }
          }
        while(!stack.empty()){
            if(stack.pop()!=popA[j++]){
                     return false;
            }
        }
        return true;
    }
```
题目：从上往下打印出二叉树的每个节点，同层节点从左至右打印。

思路：借助队列实现


```
 public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
        Queue<TreeNode> queue=new LinkedList<TreeNode>();
        ArrayList<Integer> list=new ArrayList<Integer>();
        if(null==root)
            return list;
        queue.offer(root);
        while(!queue.isEmpty()){
            TreeNode temp=queue.poll();
            list.add(temp.val);
            if(null!=temp.left){
                queue.offer(temp.left);
            }
            if(null!=temp.right){
                queue.offer(temp.right);
            }
        }
        return list;
        
    }
```

题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。


```
   public boolean VerifySquenceOfBST(int [] sequence) {
        if(sequence.length==0){
            return false;
        }
      return  judge(sequence,0,sequence.length-1);
    }
    public boolean judge(int [] sequence,int start,int last){
        if(start>=last){
	            return true;
	        }
	        int i = last;
	        while(i>start && sequence[i-1]>sequence[last]){
	            --i;
	        }
	        for(int j=i-1;j>=start;--j){
	            if(sequence[j]>sequence[last]){
	                return false;
	            }
	        }
	        return (judge(sequence,start,i-1)) && (judge(sequence,i,last-1));
        
    }
```
题目：输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)


```
import java.util.ArrayList;
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    	ArrayList<ArrayList<Integer>> pathList = new ArrayList<ArrayList<Integer>>();
       ArrayList<Integer> path=new ArrayList<Integer>();
    public ArrayList<ArrayList<Integer>> FindPath(TreeNode root,int target) {
      if(root == null)
        return  pathList; 
    path.add(root.val);
    if(root.left == null && root.right == null && target == root.val)
    {
          pathList.add(new ArrayList<Integer>(path));
    }
    if(root.val <= target && root.left != null){
        FindPath(root.left,target-root.val); 
    }  
    if(root.val <= target && root.right != null)
    {
        FindPath(root.right,target-root.val); 
    }   
    path.remove(path.size()-1);//回退到父节点
    return pathList;
    }
}
```
题目：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）


```
/*
public class RandomListNode {
    int label;
    RandomListNode next = null;
    RandomListNode random = null;

    RandomListNode(int label) {
        this.label = label;
    }
}
*/
public class Solution {
    public RandomListNode Clone(RandomListNode pHead)
    {
        if(pHead==null)return null;
        RandomListNode runner=pHead;
        RandomListNode copyCat=null;
        //First round: make copy of each nodes
        while(runner!=null){
            copyCat=new RandomListNode(runner.label);
            copyCat.next=runner.next;
            runner.next=copyCat;
            runner=copyCat.next;
        }
        
        //Second Round: assign random pointers for the copy nodes
        runner=pHead;       
        while(runner!=null){
            copyCat=runner.next;
            //notice random pointers could be null
            copyCat.random=runner.random==null?null:runner.random.next;
            runner=runner.next.next;
        }
        
        //Third round: restore the original list, and extract the copy list.
        runner=pHead;
        pHead=runner.next;
        while(true){
            copyCat=runner.next;
            runner.next=copyCat.next;
            runner=copyCat.next;
            if(runner==null){
                break;
            }
            else{
               copyCat.next=runner.next;
            }           
        }
        return pHead;
    }
}
```
题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。


```
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public TreeNode Convert(TreeNode pRootOfTree) {
        if(pRootOfTree==null){
            return null;
        }
        if(null==pRootOfTree.left&&null==pRootOfTree.right){
            return pRootOfTree;
        }
        TreeNode left=Convert(pRootOfTree.left);
        TreeNode p=left;
        while(p!=null&&p.right!=null){
            p=p.right;
        }
        if(null!=left){
            p.right=pRootOfTree;
            pRootOfTree.left=p;
        }
        TreeNode right=Convert(pRootOfTree.right);
        if(null!=right){
            right.left=pRootOfTree;
            pRootOfTree.right=right;
        }
        return left!=null?left:pRootOfTree;
        
    }
}
```

题目：输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

```
import java.util.ArrayList;
import java.util.Collections;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        ArrayList<String> res = new ArrayList<>();
        if (str != null && str.length() > 0) {
            PermutationHelper(str.toCharArray(), 0, res);
            Collections.sort(res);
        }
        return res;
       
    }
     public void PermutationHelper(char[] cs, int i, ArrayList<String> list) {
        if (i == cs.length - 1) {
            String val = String.valueOf(cs);
            if (!list.contains(val))
                list.add(val);
        } else {
            for (int j = i; j < cs.length; j++) {
                swap(cs, i, j);
                PermutationHelper(cs, i+1, list);
                swap(cs, i, j);
            }
        }
    }
 
    public void swap(char[] cs, int i, int j) {
        char temp = cs[i];
        cs[i] = cs[j];
        cs[j] = temp;
    }

}
```
题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。


```
public class Solution {
    public int MoreThanHalfNum_Solution(int [] array) {
    int result = array[0];
      int count = 1;
      int len=array.length;
 
    for(int i = 1; i < len-1; ++i)
    {
        if(array[i] == result)
             count ++;
        else 
        	{
        	count--;
        	if(count==0) {
        		count=1;
        		result=array[i];
        	}    	
        	}
     }
    if(count==1&&array[len-1] == result||count>1)
     return result;
    else return 0;
    }
      
}
```
题目：输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。


```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> list =new ArrayList<Integer>();
        if(null==input||input.length==0||k>input.length)
            return list;
        
        int temp;
        for(int i=0;i<input.length;i++){
            for(int j=i+1;j<input.length;j++){
                if(input[i]>input[j]){
                    temp=input[i];
                    input[i]=input[j];
                    input[j]=temp;
                }
            }
        }
        for(int a=0;a<k;a++){
            list.add(input[a]);
        }
        return list;
    }
}
```
题目：HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)


```
public class Solution {
    public int FindGreatestSumOfSubArray(int[] array) {
 if(null==array||0==array.length)
	        	return 0;
	        int Sum = 0;     
	        int max = array[0];            
	        for (int i = 0; i < array.length; i++) {
	            
	            if(Sum < 0){      //如果当前连续n项的和小于等于0,则没必要与后面的元素相加
	                Sum = array[i];      //Sum重新赋值
	            }else{
	                Sum += array[i];     //如果Sum的值大于0,则继续与后面的元素相加,
	            }
	            if(Sum>max){         //每次改变Sum的值都有与max进行比较
	                max = Sum;       //如果Sum的值大于max,则将Sum的值赋值给max
	            }
	        }
	        return max;
    }
}
```
题目：求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。


```
public class Solution {
    public int NumberOf1Between1AndN_Solution(int n) {
    int count=0;
	for(int i=n;i>0;i--) {
		int temp=i;
		while(temp!=0) {
			if(temp%10==1)
				count++;
			temp/=10;
		}
	}
		return count;
    }
}
```

题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323

```
import java.util.ArrayList;

public class Solution {
    public String PrintMinNumber(int [] numbers) {
         if(null==numbers||numbers.length==0)
			 return "";
		 StringBuilder s=new StringBuilder();
		 String pre,next;
		 int temp;
		 for(int i=0;i<numbers.length;i++) {
			 for(int j=i+1;j<numbers.length;j++) {
				 pre = numbers[i] + "" +  numbers[j];    //转换成字符串的形式
				 next = numbers[j] + "" +  numbers[i];
                 if(pre.compareTo(next)>0) {
                	 temp = numbers[j];
                     numbers[j] = numbers[i];
                     numbers[i] = temp;
                 }
			 }
			 s.append(numbers[i]);
		 }
		 return s.toString();
    }
}
```
题目：把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

```
import java.util.ArrayList;
public class Solution {
    public int GetUglyNumber_Solution(int index) {
		 if(index<=0)
			 return 0;
		 ArrayList<Integer> list=new ArrayList<Integer>();
		 list.add(1);
		 int t2=0,t3=0,t5=0;
		 while(list.size()<index) {
			  int m2=list.get(t2)*2;
			  int m3=list.get(t3)*3;
			  int m5=list.get(t5)*5;
			  int min=Math.min(m2,Math.min(m3,m5));
			  list.add(min);
			  if(min==m2)
				  t2++;
			  if(min==m3)
				  t3++;
			  if(min==m5)
				  t5++;
		 }
		 return list.get(list.size()-1);
    }
}
```
题目：在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.


```
public class Solution {
    public int FirstNotRepeatingChar(String str) {
         if(null==str)
			 return -1;
		 int i=0;
		 char[] arr =str.toCharArray();
		 int [] table=new int[256];
		 for(i=0;i<256;i++) {
			 table[i]=0;
		 }
		 char[] key=arr;
		 for(i=0;i<key.length;i++) {
			 int tmp=key[i];
			 table[tmp]++;
		 }
		 for(i=0;i<key.length;i++) {
			 if(table[key[i]]==1)
				 return i;
		 }
	        return -1;
    }
}
```
题目描述
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
输入描述:

题目保证输入的数组中没有的相同的数字

数据范围：

	对于%50的数据,size<=10^4

	对于%75的数据,size<=10^5

	对于%100的数据,size<=2*10^5
	
	
```
public class Solution {
     int count=0;
    public int InversePairs(int [] array) {
	   if (array == null || array.length == 0)
           return -1;
       mergeSort(array, 0, array.length - 1);
       return count;
   }

   public  void mergeSort(int[] a, int left, int right) {
       if (left < right) {
           int mid = (left + right) / 2;
           mergeSort(a, left, mid);
           mergeSort(a, mid + 1, right);
           merge(a, left, mid, right);
       }
   }

   public  void merge(int[] a, int left, int mid, int right) {
       int[] tmp = new int[right - left + 1];
       int t = right - left;//临时数组下标
       int l = mid;
       int r = right;
       while (l >= left && r >= mid + 1) {
           if (a[l] > a[r]) {
               count += (r - mid);
               tmp[t--] = a[l--];
               if (count >= 1000000007) {
                   count %= 1000000007;
               }
           } else {
               tmp[t--] = a[r--];
           }
       }
       while (l >= left) {
           tmp[t--] = a[l--];
       }
       while (r >= mid + 1) {
           tmp[t--] = a[r--];
       }
       for (int i = 0; i <= right - left; i++) {
           a[left + i] = tmp[i];
       }
   }
	
}
```
题目：输入两个链表，找出它们的第一个公共结点。
解法：可以用快慢指针法
```
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
import java.util.ArrayList;
import java.util.HashMap;
public class Solution {
    public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
 	   ListNode current1=pHead1;
		ListNode current2=pHead2;
		HashMap<ListNode,Integer> hashmap=new HashMap<ListNode,Integer>();
		while(current1!=null) {
			hashmap.put(current1,null);
			current1=current1.next;
       }
		while(current2!=null) {
			if(hashmap.containsKey(current2))
				return current2;
			current2=current2.next;
			
		}
		return null;
    }
}
```
题目：统计一个数字在排序数组中出现的次数


```
public class Solution {
    public int GetNumberOfK(int [] array , int k) {
           int number = 0;
	        if (array != null && array.length > 0)
	        {
	            int first = firstPosition(array, k, 0, array.length - 1);
	            int last = lastPosition(array, k, 0, array.length - 1);

	            if (first > -1 && last > -1)
	            {
	                number = last - first + 1;
	            }
	        }
	        return number;
	       
	    }
	 public  int firstPosition(int[] array,int k,int start,int end) {
		 if(start>end)
			 return -1;
		 int mid=(start+end)/2;
		 int midData=array[mid];
		 if(midData==k) {
			 if((mid>0&&array[mid-1]!=k)||mid==0) {
				 return mid;
			 }else {
				 end=mid-1;
			 }
		 }else if(midData>k) {
			 end=mid-1;
		 }else
			 start=mid+1;
		 return firstPosition(array, k, start, end);
	 }
	public  int lastPosition(int[] array,int k,int start,int end) {
		 if(start>end)
			 return -1;
		 int mid=(start+end)/2;
		 int midData=array[mid];
		 if(midData==k) {
			 if((mid<array.length-1&&array[mid+1]!=k)||mid==end) {
				 return mid;
			 }else {
				 start=mid+1;
			 }
		 }else if(midData>k) {
			 end=mid-1;
		 }else
			 start=mid+1; 
		 
		 return lastPosition(array, k, start, end);
	}
}
```
题目：输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。


```
/**
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public int TreeDepth(TreeNode root) {
        if(root==null)
            return 0;
        else {
             int left = TreeDepth(root.left);
             int right = TreeDepth(root.right);
             return 1 + Math.max(left, right);
          }
    }
}
```
题目：输入一棵二叉树，判断该二叉树是否是平衡二叉树。


```
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
   		if(root==null)
            return true;
        int left=deep(root.left);
        int right=deep(root.right);
        int diff=left-right;
        if(diff>1||diff<-1)
            return false;
        return IsBalanced_Solution(root.left)&&IsBalanced_Solution(root.right);
    }
	public  int deep(TreeNode pRoot){
        if(pRoot==null)
            return 0;
        int left=deep(pRoot.left);
        int right=deep(pRoot.right);
        return (left>right)?left+1:right+1;
    }
}
```
题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。


```
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果
public class Solution {
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
       if(array == null || array.length <= 1){
	            num1[0] = num2[0] = 0;
	            return;
	        }
	        int len = array.length, index = 0, sum = 0;
	        for(int i = 0; i < len; i++){
	            sum ^= array[i];
	        }
	        for(index = 0; index < 32; index++){
	            if((sum & (1 << index)) != 0) break;
	        }
	        for(int i = 0; i < len; i++){
	            if((array[i] & (1 << index))!=0){
	                num2[0] ^= array[i];
	            }else{
	                num1[0] ^= array[i];
	            }
	        } 
    }
}
```
题目：小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!


```
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> list = new ArrayList<ArrayList<Integer>>();
        ArrayList<Integer> tempList;
        for (int i = 1; i <= sum / 2; i++) {
            int start = i;
            int end = i + 1;
            tempList = new ArrayList<Integer>();
            tempList.add(start);
            while (start <= sum) {
                if (start == sum) {
                    list.add(tempList);
                    break;
                }
                tempList.add(end);
                start += end;
                end++;
            }
        }
        return list;
    }
}
```
题目：输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。


```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> FindNumbersWithSum(int [] array,int sum) {
       ArrayList<Integer> list=new ArrayList<Integer>();
	if(null==array||array.length==0)
		return list;
	int start =0;
	int end=array.length-1;
	int count=Integer.MAX_VALUE;
	while(start<end) {
		if(array[start]+array[end]<sum) {
			start++;
		}else if(array[start]+array[end]>sum) {
			end--;
		}else {
			if(array[start]*array[end]<count) {
				count=array[start]*array[end];
				list.clear();
				list.add(array[start]);
				list.add(array[end]);
			}
			 start++;
             end--;
		}
	
	}
	return list; 
    }
}
```
题目：汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！


```
public class Solution {
    public String LeftRotateString(String str,int n) {
         if (str.length()<=0){
           return "";
       }


       char[] chars = str.toCharArray();
       StringBuilder sb = new StringBuilder();
       StringBuilder sb2 = new StringBuilder();
       for (int i=0;i<n;i++){
           sb.append(chars[i]);
       }
       for (int i=n ; i<chars.length ; i++){
           sb2.append(chars[i]);
       }
       sb2.append(sb);
       return sb2.toString();
    }
}
```
题目：牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？


```
public class Solution {
    public String ReverseSentence(String str) {
  char[] chars = str.toCharArray();
    reverseString(chars,0,chars.length-1);
    int last = 0;
    for (int i=0;i<chars.length;i++){
        if (chars[i]==' ') {
            reverseString(chars,last,i-1);
            last = i+1;
        }
        if (i == chars.length-1){
            reverseString(chars,last,i);
        }
    }

    return String.valueOf(chars);
        
}
public  void reverseString(char[] str,int from,int to){
    while (from <= to){
        char t = str[from];
        str[from] = str[to];
        str[to] = t;
        from++;
        to--;
    }

}
}
```
题目:LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

```
public class Solution {
    public boolean isContinuous(int [] numbers) {
    if (numbers == null || numbers.length != 5){
            return false;
        }
        quickSort(0,numbers.length-1,numbers);
        int numberOfZero = 0;
        int numberOfGap = 0;
        //统计0的个数
        for (int i=0 ; i<numbers.length&&numbers[i]==0;i++){
            numberOfZero++;
        }
        int small = numberOfZero;
        int big = small+1;
        //看相邻的数空缺是否为0的个数;
        while (big < numbers.length){
            if (numbers[small] == numbers[big]){
                return false;
            }
            numberOfGap += (numbers[big] - numbers[small]-1);
            small = big;
            big++;
        }
        return numberOfGap <= numberOfZero;
    }
    public void quickSort(int low,int high,int numbers[]) {
	    	  int start=low;
	    	  int end=high;
	    	  int key=numbers[low];
	    	  while(start<end) {
	    		  while(start<end&&numbers[end]>=key) 
	    			  end--;
	    			  if(numbers[end]<key) {
	    				  int tem=numbers[end];
	    				  numbers[end]=numbers[start];
	    				  numbers[start]=tem;
	    			  }
	    		  while(start<end&&numbers[start]<=key) 
	    			  start++;
	    			  if(numbers[start]>key) {
	    				  int tem=numbers[end];
	    				  numbers[end]=numbers[start];
	    				  numbers[start]=tem; 
	    			  }
	    		  
	    	  }
	    	  if(start>low) quickSort(low,start-1,numbers);
	    	  if(end<high) quickSort(end+1,high,numbers);	    	  
	      }
    
}
```
题目：每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)


```
class Node{
    int no;
    Node next;
     Node(int num){
         this.no=num;
         next=null;
     }
}
public class Solution {
    public int LastRemaining_Solution(int n, int m) {
        if(n==0||m==0)
            return -1;
        Node head =new Node(0);
        Node point=head;
        for(int i=1;i<n;i++){
            point.next=new Node(i);
            point=point.next;
        }
        point.next=head;
        while(point!=point.next){
            for(int i=0;i<m-1;i++){
                point=point.next;
            }
            point.next=point.next.next;
        }
        return point.next.no;
    }
}
```
题目:求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。


```
public class Solution {
    public int Sum_Solution(int n) {
        	int sum = n;
	        boolean b = (n>0) &&((sum += Sum_Solution(n-1)) > 0);
	        return sum;
    }
}
```
题目：写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

```
public class Solution {
    public int Add(int num1,int num2) {
        if(num1==0)
            return num2;
        if(num2==0)
            return num1;
        while(num2!=0)
    	{
    		int t;
    		t=num1^num2;
    		num2=(num1&num2)<<1;
    		num1=t;
    	}
    	return num1;
    }
}
```
题目：将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

```
public class Solution {
    public int StrToInt(String str) {
      if("".equals(str)||str.length()==0)
          return 0;
        int symbol=str.charAt(0);
        int result=0;
        if (symbol >= '0' && symbol <= '9'){
            result += symbol - '0';
        }else if (!(symbol == '-' || symbol == '+')){
            return 0;
        }
        for(int i=1;i<str.length();i++){
            if(str.charAt(i)>='0'&&str.charAt(i)<='9'){
                int tem=str.charAt(i)-'0';
                result=result*10+tem;
            }else
                return 0;
        }
        return str.charAt(0)=='-'?-result:result;
    }
}
```
题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

```
public class Solution {
    // Parameters:
    //    numbers:     an array of integers
    //    length:      the length of array numbers
    //    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;
    //                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++
    //    这里要特别注意~返回任意重复的一个，赋值duplication[0]
    // Return value:       true if the input is valid, and there are some duplications in the array number
    //                     otherwise false
    public boolean duplicate(int numbers[],int length,int [] duplication) {
                 if(length==0)
	    	    	return false;
	    	    duplication[0]=-1;
	    	    quickSort(0,length-1,numbers);//快排
	    	    boolean flag=false;
	    	    for(int i=0;i<length-1;i++) {
	    	    	if(numbers[i]==numbers[i+1]) {
	    	    		duplication[0]=numbers[i];
	    	    		flag=true;
	    	    		i++;
	    	    		return flag;
	    	    	}
	    	    	
	    	    }
	    	    
	    	    return false;
	      }
	      public void quickSort(int low,int high,int numbers[]) {
	    	  int start=low;
	    	  int end=high;
	    	  int key=numbers[low];
	    	  while(start<end) {
	    		  while(start<end&&numbers[end]>=key) 
	    			  end--;
	    			  if(numbers[end]<key) {
	    				  int tem=numbers[end];
	    				  numbers[end]=numbers[start];
	    				  numbers[start]=tem;
	    			  }
	    		  while(start<end&&numbers[start]<=key) 
	    			  start++;
	    			  if(numbers[start]>key) {
	    				  int tem=numbers[end];
	    				  numbers[end]=numbers[start];
	    				  numbers[start]=tem; 
	    			  }  
	    	  }
	    	  if(start>low) quickSort(low,start-1,numbers);
	    	  if(end<high) quickSort(end+1,high,numbers);
	    	  
	      }
    
}
```
题目：给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。


```
import java.util.ArrayList;
public class Solution {
    public int[] multiply(int[] A) {
 int length = A.length;
        int[] B = new int[length];
        if (length == 0){
            return B;
        }
        int[] before = new int[length];
        int[] after = new int[length];
        before[0] = 1;
        after[0] = 1;
        for (int i=0;i<length;i++){
            if (i>0){
                before[i] = A[i-1]*before[i-1];
            }
            if (i<length-1){
                after[i+1] = after[i]*A[length-i-1];
            }
        }
        for (int i=0;i<length;i++)
            B[i] = before[i]*after[length-i-1];

        return B;
    }
}
```
题目：请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。


```
import java.util.ArrayList;
public class Solution {
    //Insert one char from stringstream
      ArrayList<Character> list = new ArrayList<Character>();
     int[] counts = new int[128];
    public void Insert(char ch){
         if(counts[(int)ch] ==0){
            list.add(ch);
        }else if(list.contains(ch)){
            list.remove((Character)ch);
        }
        counts[(int)ch] = counts[(int)ch]+1;
    }
  //return the first appearence once char in current stringstream
    public char FirstAppearingOnce(){
    return list.isEmpty()?'#':list.get(0);
    }
}
```
题目：给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。
可以使用快慢指针法

```
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
import java.util.ArrayList;
public class Solution {

    public ListNode EntryNodeOfLoop(ListNode pHead)
    {
         ArrayList<ListNode> list=new ArrayList<ListNode>();
	    	  ListNode root=pHead;
	    	  if(null==pHead)
	    		  return null;
	    	  while(root!=null) {
                   if(list.contains(root))
	    			  return root;
	    		  list.add(root);
	    		  root=root.next;
	    		  
	    	  }
	    	  return null;
    }
}
```
题目：在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5


```
/*
 public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public ListNode deleteDuplication(ListNode pHead){
        	   if (pHead == null)
	               return null;
	           ListNode node = new ListNode(0);
	           node.next = pHead;
	           ListNode pre = node;
	           ListNode p = pHead;
	           while (p!= null && p.next != null){
	               if (p.val == p.next.val){
	                   int temp = p.val;
	                   while (p != null &&p.val == temp){
	                       p = p.next;
	                   }
	                   pre.next = p;
	               }else {
	                   pre = p;
	                   p = p.next;
	               }
	           }
	           return node.next;
    }
}
```
题目：给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```
/*
public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
*/
public class Solution {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
         if(null==pNode)
	        	  return null;
	          if(pNode.right!=null) {
	        	  pNode=pNode.right;
	        	  while(pNode.left!=null) {
	        		  pNode=pNode.left;
	        	  }
	        	  return pNode;
	          }
	          
	          while(pNode.next!=null) {
	        	  if(pNode == pNode.next.left)
	                  return pNode.next;
	              pNode = pNode.next;
	          }
	          return null;
    }
}
```
题目：请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

```
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    boolean isSymmetrical(TreeNode pRoot){
         if (pRoot == null){
            return true;
        }
        return comRoot(pRoot.left,pRoot.right);
    }
    public boolean comRoot(TreeNode left,TreeNode right){
        if (left == null) return right == null;
        if (right == null) return false;
        if (left.val != right.val) return false;
        return comRoot(left.left,right.right)&&comRoot(left.right,right.left);
    }
}
```
题目描述
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。


```
import java.util.ArrayList;
import java.util.LinkedList;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    public ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
  ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
	    	  ArrayList<ArrayList<Integer>> list1=new ArrayList<ArrayList<Integer>>();
	    	  if (pRoot == null){
	              return list;
	          }
	    	  ArrayList<Integer> tmpList=new ArrayList<Integer>();
	    	  LinkedList<TreeNode> stack=new LinkedList<TreeNode>();
	    	  stack.add(pRoot);
	    	  TreeNode last=pRoot;
	    	  TreeNode nlast=pRoot;
	    	  while(!stack.isEmpty()) {
	    		  TreeNode  currentNode=stack.poll();
	    		 if(currentNode.left!=null){
	    			 stack.offer(currentNode.left);
	    			 nlast=stack.getLast();
	    		 }
	    		 if(currentNode.right!=null){
	    			 stack.offer(currentNode.right);
	    			 nlast=stack.getLast();
	    		 }
	    		 if (currentNode==last) {
	    			 tmpList.add(currentNode.val);
	 				list.add(tmpList);
	 				tmpList=new ArrayList<Integer>();
	 				last=nlast;
	 			} else {
	 				tmpList.add(currentNode.val);
	 			}	 
	    	  }
	    	  for(int i=0;i<list.size();i+=2) {
	    		  list1.add(list.get(i));
	    		  if(i<list.size()-1) {
	    		    list1.add(reverse(list.get(i+1)));
	    		  }
	    	  }
	    	  return list1;    
	      }	      
	      public  ArrayList<Integer> reverse(ArrayList<Integer> layerlist){
	          int length = layerlist.size();
	          ArrayList<Integer> reverseList = new ArrayList<Integer>();
	          for (int i=length-1;i>=0;i--){
	              reverseList.add(layerlist.get(i));
	          }
	          return reverseList;
	      }

}
```
题目描述
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。


```
import java.util.ArrayList;
import java.util.LinkedList;

/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
     ArrayList<ArrayList<Integer>> list=new ArrayList<ArrayList<Integer>>();
         if (pRoot == null){
	              return list;
	          }
	    	  ArrayList<Integer> tmpList=new ArrayList<Integer>();
	    	  LinkedList<TreeNode> stack=new LinkedList<TreeNode>();
	    	  stack.add(pRoot);
	    	  TreeNode last=pRoot;
	    	  TreeNode nlast=pRoot;
	    	  while(!stack.isEmpty()) {
	    		 TreeNode currentNode=stack.poll();
	    		 if(currentNode.left!=null){
	    			 stack.offer(currentNode.left);
	    			 nlast=stack.getLast();
	    		 }
	    		 if(currentNode.right!=null){
	    			 stack.offer(currentNode.right);
	    			 nlast=stack.getLast();
	    		 }
	    		 if (currentNode==last) { 
                     tmpList.add(currentNode.val);
	 				list.add(tmpList);
	 				tmpList=new ArrayList<Integer>();
	 				last=nlast;
	 			} else {
	 				tmpList.add(currentNode.val);
	 			}	    			 
	    	  }
	    	  return list;
    }
    
}
```
题目描述
请实现两个函数，分别用来序列化和反序列化二叉树

```
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
  int index = -1;
	    String Serialize(TreeNode root) {
	    	 StringBuilder sb = new StringBuilder();
	         if (root == null){
	             sb.append("#,");
	             return sb.toString();
	         }
	         sb.append(root.val+",");
	         sb.append(Serialize(root.left));
	         sb.append(Serialize(root.right));
	         return sb.toString();
	  }
	    TreeNode Deserialize(String str) {
	    	 index++;
	         int length = str.length();
	         if (index >= length){
	             return null;
	         }

	         String[] strr = str.split(",");
	         TreeNode node = null;
	         if (!strr[index].equals("#")){
	             node = new TreeNode(Integer.valueOf(strr[index]));
	             node.left = Deserialize(str);
	             node.right= Deserialize(str);
	         }

	         return node;
	  }
}
```
题目描述
给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。


```
import java.util.Stack;
/*
public class TreeNode {
    int val = 0;
    TreeNode left = null;
    TreeNode right = null;

    public TreeNode(int val) {
        this.val = val;

    }

}
*/
public class Solution {
    TreeNode KthNode(TreeNode pRoot, int k){
         if(pRoot==null) return null;
        int i = 0;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        TreeNode p = pRoot;
        while(p!=null || stack.size()!=0){
            while(p!=null){
                stack.add(p);
                p = p.left;

            }
            if(stack.size()!=0){
                p = stack.pop();
                if(++i==k){
                    return p;
                }
                p = p.right;
            }
        }
        return null;
    }
}
```
